% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/core.R
\name{calSensitivity}
\alias{calSensitivity}
\title{Compute sensitivity values of node/edge groups}
\usage{
calSensitivity(networks, stateSet, mutateMethod = "rule flip",
               groupSet = 0, mutationTime = 1000L, numRuleSets = 1)
}
\arguments{
\item{networks}{A network or a set of networks used for the calculation}

\item{stateSet}{The identifier for accessing a set of initial-states}

\item{mutateMethod}{The method of mutation to be performed, default is "rule flip"}

\item{groupSet}{The indexing number of node/edge groups for whose sensitivity values are calculated. Default is 0 which specify the latest generated groups.}

\item{mutationTime}{The period of time in which the mutation occurs, default is 1000}

\item{numRuleSets}{Number of random Nested Canalyzing Function sets, default is 1}
}
\value{
The updated network objects including sensitivity values of the examined node/edge groups.
}
\description{
Computes sensitivity values of node/edge groups in a network or in a set of networks, and returns the network objects with newly calculated results.
}
\details{
This function computes sensitivity values of node/edge groups in a specific network or in a set of networks.
The calculation is based on a set of initial-states specified by an identifier \strong{\code{stateSet}}.
The node/edge groups in each network are determined by an indexing number \strong{\code{groupSet}}.
For example, the number \code{1} would point to the data frame of node/edge groups named \strong{\code{Group_1}}.
For mutation settings, there exist some embedded mutations:
"state flip", "rule flip", "outcome shuffle", "knockout", "overexpression",
"edge removal", "edge attenuation", "edge addition", "edge sign switch", and "edge reverse".
Besides, users can define their own mutation and apply here as shown in the below example.
Users can also set the operational time of the mutation as determined by the parameter \strong{\code{mutationTime}}.
Finally, synchronous updating scheme is used for calculating state transitions. Single or multiple sets of random update-rules are generated based on the
parameter \code{numRuleSets}.

For each network, the sensitivity values are stored in the same data frame of node/edge groups.
The data frame has one column for group identifiers (lists of nodes/edges),
and some next columns containing their sensitivity values according to each set of random update-rules.
}
\examples{
# load an example network, the large-scale human signaling network
data(hsn)

# setup OpenCL for parallel computation
setOpencl("gpu")

# generate 1000 random initial-states
states <- generateStates(hsn, 1000)
print(states)

# generate all possible groups each containing a single node in the HSN network
hsn <- generateGroups(hsn, "all", 1, 0)

# calculate sensitivity values of all nodes against the knockout mutation
hsn <- calSensitivity(hsn, states, "knockout")

# calculate sensitivity values against a user-defined mutation
hsn <- calSensitivity(hsn, states, "D:\\\\mod\\\\UserMutation.java")

# view the calculated sensitivity values and export all results to files
printSensitivity(hsn)
output(hsn)
}
\seealso{
\code{\link{generateStates}}, \code{\link{generateState}}, \code{\link{generateGroups}}, \code{\link{generateGroup}}, \code{\link{findFBLs}}, \code{\link{findFFLs}}, \code{\link{calCentrality}}, \code{\link{findAttractors}}
}

